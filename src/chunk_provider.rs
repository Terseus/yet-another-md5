use crate::chunk::Chunk;
use crate::chunk::CHUNK_SIZE_BYTES;
use crate::conversions::u64_to_u8;
use crate::md5_error::Md5Error;
use log::debug;
use log::trace;
use std::io::Read;

const INITIAL_BIT_SIZE_BYTES: usize = 1;
const INITIAL_BIT: u8 = 0x80; // 1 in big endian.
const LENGTH_SIZE_BYTES: usize = 8; // 64 / 8
const ZERO_PADDING_MAX_SIZE_BYTES: usize =
    CHUNK_SIZE_BYTES - LENGTH_SIZE_BYTES - INITIAL_BIT_SIZE_BYTES;

#[derive(Debug, PartialEq, Eq)]
enum PaddingState {
    InitialBit,
    Length,
    Done,
}

pub struct ChunkProvider<'a> {
    input: &'a mut dyn Read,
    padding_state: PaddingState,
    size: u64,
}

impl<'a> ChunkProvider<'a> {
    pub fn new(input: &'a mut dyn Read) -> Self {
        ChunkProvider {
            input,
            padding_state: PaddingState::InitialBit,
            size: 0,
        }
    }

    fn write_length(&self, chunk: &mut Chunk) {
        let mut length: [u8; 8] = [0; 8];
        u64_to_u8(&(self.size & u64::MAX), &mut length);
        for x in 0..8 {
            let chunk_position = ZERO_PADDING_MAX_SIZE_BYTES + x + 1;
            let length_position = x;
            trace!(
                "chunk[{:?}]({:?}) = length[{:?}]({:?})",
                chunk_position,
                chunk.0[chunk_position],
                length_position,
                length[length_position]
            );
            chunk.0[chunk_position] = length[length_position];
        }
    }

    pub fn read(&mut self, buffer: &mut Chunk) -> Result<Option<()>, Md5Error> {
        let bytes_read = match self.input.read(&mut buffer.0) {
            Ok(value) => value,
            Err(error) => {
                return Err(Md5Error::ReadError(error));
            }
        };
        debug!("bytes_read: {}", bytes_read);
        if bytes_read == 0 && self.padding_state == PaddingState::Done {
            return Ok(None);
        }
        // Length is in bits
        self.size += u64::try_from(bytes_read * 8).unwrap_or_else(|error| {
            panic!(
                "Error reading bytes_read ({:?}) as u64: {:?}",
                bytes_read, error
            )
        });
        debug!("size: {:?}", self.size);
        trace!("buffer: {}", buffer);
        if bytes_read == 0 {
            debug!("empty chunk readed");
            debug!("current padding state: {:?}", self.padding_state);
            buffer.0.fill(0);
            match &self.padding_state {
                PaddingState::InitialBit => {
                    buffer.0[0] = INITIAL_BIT;
                    self.write_length(buffer);
                    self.padding_state = PaddingState::Done;
                }
                PaddingState::Length => {
                    self.write_length(buffer);
                    self.padding_state = PaddingState::Done;
                }
                PaddingState::Done => {
                    return Ok(None);
                }
            }
            trace!("chunk with padding: {}", buffer);
            return Ok(Some(()));
        }
        if bytes_read < buffer.len() {
            debug!("last chunk readed");
            buffer.0[bytes_read] = INITIAL_BIT;
            buffer.0[bytes_read + 1..].fill(0);
            self.padding_state = PaddingState::Length;
            if bytes_read <= ZERO_PADDING_MAX_SIZE_BYTES {
                debug!("chunk can hold padding");
                self.write_length(buffer);
                trace!("buffer with padding: {}", buffer);
                self.padding_state = PaddingState::Done;
            }
        }
        Ok(Some(()))
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use rstest::rstest;
    use std::io::Cursor;

    // Inputs and outputs taken from https://rosettacode.org/wiki/MD5/Implementation_Debug
    #[rstest]
    #[case(
        vec![],
        vec![
            Chunk::from([
                0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            ])
        ]
    )]
    #[case(
        vec![0x61],
        vec![
            Chunk::from([
                0x61, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            ])
        ]
    )]
    #[case(
        vec![0x61, 0x62, 0x63],
        vec![
            Chunk::from([
                0x61, 0x62, 0x63, 0x80, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            ])
        ]
    )]
    #[case(
        vec![
            0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20,
            0x64, 0x69, 0x67, 0x65, 0x73, 0x74,
        ],
        vec![
            Chunk::from([
                0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20,
                0x64, 0x69, 0x67, 0x65, 0x73, 0x74, 0x80, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            ])
        ]
    )]
    #[case(
        vec![
            0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
            0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,
            0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
            0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
            0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,
            0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
            0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33,
            0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
        ],
        vec![
            Chunk::from([
                0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
                0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,
                0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
                0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
                0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,
                0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
                0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33,
                0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x80, 0x00,
            ]),
            Chunk::from([
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0xf0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            ])
        ]
    )]
    #[case(
        vec![
            0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
            0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
            0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34,
            0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32,
            0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
            0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
            0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
            0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34,
            0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32,
            0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
        ],
        vec![
            Chunk::from([
                0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
                0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
                0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34,
                0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32,
                0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
                0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
                0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
                0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34,
            ]),
            Chunk::from([
                0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32,
                0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30,
                0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x80, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            ])
        ]
    )]
    fn test_padding(#[case] contents: Vec<u8>, #[case] expected: Vec<Chunk>) {
        let mut result: Vec<Chunk> = vec![];
        let mut buffer = Chunk::empty();
        let mut cursor = Cursor::new(contents);
        let mut chunk_provider = ChunkProvider::new(&mut cursor);
        while chunk_provider.read(&mut buffer).unwrap().is_some() {
            result.push(buffer);
        }
        assert_eq!(result, expected);
    }
}
